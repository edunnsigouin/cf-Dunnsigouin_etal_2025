"""
Converts era5 model format data into binary if over/under
a climatological percentile threshold derived from previous years
e.g., converts era5 model format data (lead time,lat,lon) for year 2021
into binary if above/below percentile thresholds derived from years 2001-2020
in format (dayofyear,lat,lon).
 
NOTE: this is done for both era5 daily, climatology and persistence data in model format
(files structured per initialization date of forecast)

NOTE2: the climatological mean precip can be BIGGER than for example percentiles > 75. 
This occurs because the distribution can have a long tail, skewing the mean towards the
extremes. Thus, the output of this script is not just zero everywhere.
"""

import numpy  as np
import xarray as xr
import os
from dask.diagnostics  import ProgressBar
from forsikring        import misc,s2s,config
from matplotlib        import pyplot as plt

def read_percentile_thresholds(time_flag,path_in,variable,grid,years):
    """
    Reads in percentile thresholds and combines into one file
    if more than one file. Written here to clean up code below.
    """
    if time_flag == 'time':
        filename1 = 'xyt_percentile_' + variable + '_' + grid + '_agg_1_' + str(years[0]) + '-' + str(years[-1]) + '.nc'
        da_pval   = xr.open_dataset(path_in + filename1)['percentile']
    elif time_flag == 'timescale':
        if grid == '0.25x0.25':
            filename1    = path_in + 'xyt_percentile_' + variable + '_' + grid + '_agg_1_' + str(years[0]) + '-' + str(years[-1]) + '.nc'
            filename2    = path_in + 'xyt_percentile_' + variable + '_' + grid + '_agg_2_' + str(years[0]) + '-' + str(years[-1]) + '.nc'
            filename3    = path_in + 'xyt_percentile_' + variable + '_' + grid + '_agg_4_' + str(years[0]) + '-' + str(years[-1]) + '.nc'
            filename4    = path_in + 'xyt_percentile_' + variable + '_' + grid + '_agg_7_' + str(years[0]) + '-' + str(years[-1]) + '.nc'
            filenames_in = [filename1] + [filename2] + [filename3] + [filename4] 
        elif grid == '0.5x0.5':
            filename5    = path_in + 'xyt_percentile_' + variable + '_' + grid + '_agg_13_' + str(years[0]) + '-' + str(years[-1]) + '.nc'
            filename6    = path_in + 'xyt_percentile_' + variable + '_' + grid + '_agg_18_' + str(years[0]) + '-' + str(years[-1]) + '.nc'
            filenames_in = [filename5] + [filename6]
        with ProgressBar():    
            da_pval = xr.open_mfdataset(filenames_in,combine='nested',concat_dim='timescale')['percentile'].compute()        
    return da_pval

def init_binary(variable,dim,time,pvals):
    """ 
    Initializes output array used below. 
    Written here to clean up code.                                                                                                                      
    """
    data       = np.zeros((pvals.size,time.size,dim.nlatitude,dim.nlongitude),dtype=np.int16)
    dims       = ["pval","time","latitude","longitude"]
    coords     = dict(pval=pvals,time=time,latitude=dim.latitude,longitude=dim.longitude)
    attrs      = dict(description='binary values over percentile threshold',units='unitless')
    name       = variable
    binary     = xr.DataArray(data=data,dims=dims,coords=coords,attrs=attrs,name=name)
    return binary

# INPUT -----------------------------------------------
time_flag         = 'timescale'                   # time or timescale
data_flag         = 'daily'                   # daily,clim,pers
variable          = 'tp24'                   # tp24,rn24,mx24rn6,mx24tp6,mx24tpr
init_start        = '20210104'               # first initialization date of forecast (either a monday or thursday)
init_n            = 1                      # number of forecasts 
grids             = ['0.25x0.25','0.5x0.5']            # '0.25x0.25' & '0.5x0.5'
pvals             = np.array([0.75,0.8,0.85,0.9,0.95,0.99]) # percentile thresholds
comp_lev          = 5                        # compression level (0-10) of netcdf putput file
write2file        = False
# -----------------------------------------------------

misc.tic()

# define stuff  
years        = np.arange(int(init_start[:4])-20,int(init_start[:4])) # hindcast years for forecasts
init_dates   = s2s.get_init_dates(init_start,init_n)
init_dates   = init_dates.strftime('%Y-%m-%d').values
path_in_O    = config.dirs['era5_forecast_' + data_flag] + variable + '/'
path_in_pval = config.dirs['era5_cont_percentile'] + variable + '/'
path_out     = config.dirs['era5_forecast_' + data_flag + '_binary'] + variable + '/'

for grid in grids:

    # read in thresholds
    da_pval = read_percentile_thresholds(time_flag,path_in_pval,variable,grid,years)

    for date in init_dates:

        print('\nconverting to binary ' + variable + ' for ' + grid + ' and initialization ' + date)
        
        # define stuff
        dim           = s2s.get_dim(grid,'daily')
        filename_O    = variable + '_' + grid + '_' + date + '.nc'
        filename_out  = variable + '_' + time_flag + '_' + grid + '_' + date + '.nc'
        
        # read data
        da_O = xr.open_dataset(path_in_O + filename_O)[variable]

        # resample time into timescales if required
        da_O = s2s.time_2_timescale(da_O,time_flag,datetime64=True)
            
        # convert to binary.find forecast date corresponding to day of year in threshold array
        # and then make 1 or 0 if its over or under threshold.
        binary = init_binary(variable,dim,da_O.time,pvals)
        for pval in range(0,pvals.size):
            for t in range(0,da_O.time.size):
                doy = da_O['time.dayofyear'][t].values - 1 # potential problem here with leap year days (e.g. 2020) !!!!!!!!!!!!!!!!!!!!!!!!!!
                if time_flag  == 'time': threshold = da_pval[:,doy,:,:].sel(pval=pvals[pval],method='nearest').values
                elif time_flag == 'timescale': threshold = da_pval[t,:,doy,:,:].sel(pval=pvals[pval],method='nearest').values # extra 'timescale' dimension in threshold 
                binary[pval,t,:,:] = (da_O[t,:,:].values >= threshold[:,:]).astype(np.int16)

        # write output     
        if write2file:
            binary.to_netcdf(path_out + filename_out)
            s2s.compress_file(comp_lev,3,filename_out,path_out) 

        da_O.close()
    da_pval.close()

misc.toc()


